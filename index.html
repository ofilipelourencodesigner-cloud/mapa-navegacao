<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Rotas Escolares — Navegação</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <style>
    :root{
      --bg:#f6f7fb; --ink:#0b1220; --muted:#64748b;
      --brand:#0b74de; --brand2:#3b82f6; --halo:#9ec5ff;
      --traveled:#8e9ab0; --driver:#ff5e3a; --card:#fff; --line:#e8eef9;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
      font-family:Inter,system-ui,Arial,Helvetica,sans-serif}
    #top{position:fixed;left:0;right:0;top:0;z-index:10;background:var(--card);
      border-bottom:1px solid var(--line);padding:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    #title{font-weight:800;font-size:20px;margin-right:6px}
    input,button{padding:10px 12px;border:1px solid #d6e1f4;border-radius:10px;font-size:15px;background:#fff}
    .primary{background:var(--brand);color:#fff;border:none;font-weight:700}
    .ghost{background:#fff}
    .muted{color:var(--muted)}
    #map{position:fixed;left:0;right:0;top:72px;bottom:168px}
    #panel{position:fixed;left:0;right:0;bottom:0;height:168px;background:var(--card);
      border-top:1px solid var(--line);padding:12px;display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
    #next .t{font-weight:900;font-size:18px;margin-bottom:6px}
    #next .s{font-size:14px;color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .tag{font-size:12px;padding:4px 8px;border:1px solid #d6e1f4;border-radius:999px}
    .marker-num{background:#fff;border:2px solid var(--brand);border-radius:10px;padding:6px 8px;font-weight:800;font-size:12px}
    #float{position:fixed;right:12px;bottom:188px;display:flex;flex-direction:column;gap:8px;z-index:12}
    .fab{width:56px;height:56px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:#fff;border:1px solid var(--line);box-shadow:0 8px 20px rgba(0,0,0,.12);font-size:22px;cursor:pointer}
    @media(min-width:760px){#map{top:84px;bottom:188px}#panel{height:188px}}
  </style>
</head>
<body>
  <div id="top">
    <div id="title">Rotas Escolares</div>
    <label for="rotaInput" class="muted" style="font-size:14px">Digite a rota:</label>
    <input id="rotaInput" placeholder="ex.: 1" style="min-width:180px" />
    <button id="btnOverview" class="ghost">Mostrar visão geral</button>
    <button id="btnStart" class="primary">Iniciar Rota</button>
    <label class="row muted" style="margin-left:auto;font-size:13px">
      <input type="checkbox" id="vozToggle" style="transform:scale(1.2);margin-right:6px"> Voz
    </label>
    <div id="status" class="muted" style="font-size:13px">Status: pronto</div>
  </div>

  <div id="map"></div>

  <div id="float">
    <div id="btnPause" class="fab" title="Pausar">⏸️</div>
    <div id="btnStop" class="fab" title="Finalizar">⏹️</div>
  </div>

  <div id="panel">
    <div id="next">
      <div class="t" id="nextTitle">Nenhuma rota selecionada</div>
      <div class="s" id="nextSub">Digite o número da rota, toque em <b>Mostrar visão geral</b> e depois <b>Iniciar Rota</b>.</div>
      <div class="row" id="miniInfo" style="margin-top:6px"></div>
    </div>
    <div class="row" style="align-self:end">
      <button id="btnCenter" class="ghost">Centralizar</button>
    </div>
  </div>

  <script>
  /* ===== CONFIG ===== */
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiZmlsaXBldHJhbnNwb3J0ZSIsImEiOiJjbWVtMTk1eHowZzU3Mmlva2dmejF3a3JrIn0.AqLF-HXkCaxuWL6eLBBrOQ';
  mapboxgl.accessToken = MAPBOX_TOKEN;

  /* ===== Estado ===== */
  let MAP=null, ROTAS=[], rotaSel=null, PONTOS=[], markers=[];
  let plannedGeo=null;
  let navSteps=[], stepIdx=0;
  let driverMarker=null, watchId=null, wakeLock=null;
  let startProg=null, lastProg=null;
  let smoothedBearing=null;
  let isNavigating = false;

  const $ = id => document.getElementById(id);
  const setStatus = t => $('status').textContent = t;
  const setNext = (t,s) => { $('nextTitle').textContent=t; $('nextSub').textContent=s||''; };

  /* ===== Utils Geo ===== */
  const toRad = d=> d*Math.PI/180;
  function distanceM(aLat,aLon,bLat,bLon){
    const R=6371000,φ1=toRad(aLat),φ2=toRad(bLat),dφ=toRad(bLat-aLat),dλ=toRad(bLon-aLon);
    const x=Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
    return R*2*Math.atan2(Math.sqrt(x),Math.sqrt(1-x));
  }
  function bearingDeg(aLat,aLon,bLat,bLon){
    const φ1=toRad(aLat),φ2=toRad(bLat),λ1=toRad(aLon),λ2=toRad(bLon);
    const y=Math.sin(λ2-λ1)*Math.cos(φ2);
    const x=Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
    return (Math.atan2(y,x)*180/Math.PI+360)%360;
  }
  function smoothBearing(newB){
    if(smoothedBearing==null){ smoothedBearing=newB; return newB; }
    let delta=((newB - smoothedBearing + 540)%360)-180;
    smoothedBearing=(smoothedBearing + delta*0.25 + 360)%360;
    return smoothedBearing;
  }
  function llToMeters(lon,lat){
    const x=lon*20037508.34/180;
    let y=Math.log(Math.tan((90+lat)*Math.PI/360))/(Math.PI/180);
    y=y*20037508.34/180; return {x,y};
  }
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx+dy*dy); }

  function nearestProgress(pt, coords){
    const P=llToMeters(pt[0],pt[1]);
    let best={index:0,t:0,dist:Infinity};
    for(let i=0;i<coords.length-1;i++){
      const A=llToMeters(coords[i][0],coords[i][1]);
      const B=llToMeters(coords[i+1][0],coords[i+1][1]);
      const l2=(B.x-A.x)**2+(B.y-A.y)**2;
      let t=0;
      if(l2>0){ t=((P.x-A.x)*(B.x-A.x)+(P.y-A.y)*(B.y-A.y))/l2; t=Math.max(0,Math.min(1,t)); }
      const proj={x:A.x+t*(B.x-A.x), y:A.y+t*(B.y-A.y)};
      const d=dist2(P,proj);
      if(d<best.dist) best={index:i,t,dist:d};
    }
    return best;
  }

  function coordAt(coords, prog){
    const i=Math.max(0,Math.min(coords.length-2, prog.index));
    const t=Math.max(0,Math.min(1,prog.t));
    const s=coords[i], e=coords[i+1];
    return [ s[0]+(e[0]-s[0])*t,  s[1]+(e[1]-s[1])*t ];
  }

  function sliceFrom(coords, prog){
    const head = coordAt(coords, prog);
    const out = [head];
    for (let k = prog.index + 1; k < coords.length; k++) {
      out.push(coords[k]);
    }
    if (out.length < 2) {
      if (coords.length >= 2) return coords.slice(coords.length - 2);
      return out;
    }
    const a = out[0], b = out[1];
    if (a[0] === b[0] && a[1] === b[1]) {
      const i = Math.max(0, Math.min(coords.length - 2, prog.index));
      return [coords[i], coords[i + 1], ...coords.slice(i + 2)];
    }
    return out;
  }

  function sliceBetween(coords, startProg, currentProg){
    if (!startProg || !currentProg) return [];
    
    const startIdx = startProg.index;
    const startT = startProg.t;
    const currentIdx = currentProg.index;
    const currentT = currentProg.t;
    
    // Se estamos no mesmo segmento
    if (startIdx === currentIdx) {
      if (currentT <= startT) return [];
      const p1 = coordAt(coords, startProg);
      const p2 = coordAt(coords, currentProg);
      return [p1, p2];
    }
    
    // Se avançamos para segmentos diferentes
    const traveled = [];
    
    // Primeiro segmento (parcial)
    traveled.push(coordAt(coords, startProg));
    
    // Segmentos completos entre startIdx e currentIdx
    for (let i = startIdx + 1; i < currentIdx; i++) {
      traveled.push(coords[i]);
    }
    
    // Último segmento (parcial)
    traveled.push(coordAt(coords, currentProg));
    
    return traveled;
  }

  function speak(text){
    if(!$('vozToggle').checked) return;
    try{ 
      const u=new SpeechSynthesisUtterance(text); 
      u.lang='pt-BR'; 
      u.rate = 0.9;
      speechSynthesis.cancel(); 
      speechSynthesis.speak(u); 
    }catch(e){}
  }

  /* ===== Mapa ===== */
  function initMap(){
    MAP=new mapboxgl.Map({
      container:'map',
      style:'mapbox://styles/mapbox/navigation-day-v1',
      center:[-48.40401957175889,-22.960993547862227], 
      zoom:12
    });
    
    MAP.addControl(new mapboxgl.NavigationControl());
    
    MAP.on('load', ()=>{
      MAP.addSource('route-source',{
        type:'geojson',
        data:{type:'FeatureCollection',features:[]}
      });

      // Linha percorrida (cinza)
      MAP.addLayer({ 
        id:'route-traveled', 
        type:'line', 
        source:'route-source',
        filter:['==',['get','kind'],'traveled'],
        paint:{
          'line-color':'#8e9ab0',
          'line-width':8,
          'line-opacity':0.95
        }
      });
      
      // Halo da rota ativa
      MAP.addLayer({ 
        id:'route-halo', 
        type:'line', 
        source:'route-source',
        filter:['==',['get','kind'],'active'],
        paint:{
          'line-color':'#9ec5ff',
          'line-width':14,
          'line-opacity':0.7
        }
      });
      
      // Rota ativa (azul)
      MAP.addLayer({ 
        id:'route-active', 
        type:'line', 
        source:'route-source',
        filter:['==',['get','kind'],'active'],
        layout:{
          'line-join':'round',
          'line-cap':'round'
        },
        paint:{
          'line-color':'#3b82f6',
          'line-width':8,
          'line-opacity':0.98
        }
      });
    });
    
    MAP.on('error', e=>{
      console.error('Erro no mapa:', e);
      setStatus('Erro no mapa base');
    });
  }
  
  initMap();

  /* ===== Dados ===== */
  async function loadRotas(){
    try {
      const r = await fetch('rotas.json', {cache:'no-store'});
      ROTAS = await r.json();
      console.log('Rotas carregadas:', ROTAS.length);
    } catch (e) {
      console.error('Erro ao carregar rotas:', e);
      ROTAS = [];
      setStatus('Erro ao carregar rotas');
    }
  }
  
  loadRotas();

  function getRotaSelecionada(){
    const txt = String($('rotaInput').value||'').trim();
    const id = parseInt(txt, 10);
    console.log('Buscando rota ID:', id, 'em', ROTAS);
    return ROTAS.find(r=>r.id===id) || null;
  }

  /* ===== UI Eventos ===== */
  $('btnOverview').addEventListener('click', showOverview);
  $('btnStart').addEventListener('click', startNavigation);
  $('btnPause').addEventListener('click', pauseNavigation);
  $('btnStop').addEventListener('click', stopNavigation);
  $('btnCenter').addEventListener('click', centerOnDriver);

  async function showOverview(){
    rotaSel = getRotaSelecionada();
    if(!rotaSel){ 
      alert('Digite o número da rota (ex.: 1)'); 
      return; 
    }

    console.log('Mostrando overview da rota:', rotaSel);

    // Limpar estado anterior
    markers.forEach(m=>m.remove()); 
    markers=[];
    plannedGeo=null; 
    navSteps=[]; 
    stepIdx=0; 
    startProg=null; 
    lastProg=null;
    isNavigating = false;

    // Criar marcadores dos pontos
    PONTOS = rotaSel.pontos.map(p=>({
      nome:p.nome,
      lat:+p.lat||+p.latitude,
      lon:+p.lon||+p.longitude,
      obs:p.obs||''
    }));
    
    PONTOS.forEach((p,i)=>{
      const el=document.createElement('div'); 
      el.className='marker-num'; 
      el.textContent=(i+1);
      const mk=new mapboxgl.Marker({element:el})
        .setLngLat([p.lon,p.lat])
        .setPopup(new mapboxgl.Popup({offset:8})
          .setHTML(`<b>${i+1} — ${p.nome}</b><br>${p.obs||''}`))
        .addTo(MAP);
      markers.push(mk);
    });

    // Obter rota do Mapbox Directions
    try{
      const coords=PONTOS.map(p=>`${p.lon},${p.lat}`).join(';');
      const qs=new URLSearchParams({
        access_token:MAPBOX_TOKEN,
        geometries:'geojson',
        overview:'full',
        steps:'true',
        language:'pt-BR'
      });
      
      const url=`https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?${qs}`;
      console.log('Buscando direções:', url);
      
      const res=await fetch(url);
      if(!res.ok) throw new Error(`Directions ${res.status}`);
      
      const j=await res.json();
      const route=j.routes[0];
      plannedGeo=route.geometry;
      
      console.log('Rota planejada:', plannedGeo);

      // Extrair passos de navegação
      navSteps=[];
      route.legs.forEach(leg=>{
        leg.steps.forEach(s=>{
          if(s.maneuver && s.maneuver.instruction){
            navSteps.push({
              text: s.maneuver.instruction,
              loc: {
                lon: s.maneuver.location[0], 
                lat: s.maneuver.location[1]
              },
              distance: s.distance,
              duration: s.duration
            });
          }
        });
      });
      
      stepIdx=0;

      // Mostrar rota completa
      updateRouteLayers([], plannedGeo.coordinates);

      // Ajustar visualização para mostrar toda a rota
      const xs=plannedGeo.coordinates.map(c=>c[0]);
      const ys=plannedGeo.coordinates.map(c=>c[1]);
      MAP.fitBounds([
        [Math.min(...xs), Math.min(...ys)],
        [Math.max(...xs), Math.max(...ys)]
      ], {padding:60});
      
      setNext(`Rota ${rotaSel.id} — ${rotaSel.nome}`, 'Toque em "Iniciar Rota" para começar a navegação.');
      setStatus(`Visão geral — ${(route.distance/1000).toFixed(1)} km • ${Math.round(route.duration/60)} min`);

      // Atualizar informações da rota
      const mi=$('miniInfo'); 
      mi.innerHTML='';
      const a=document.createElement('div'); 
      a.className='tag'; 
      a.textContent=`${PONTOS.length} pontos`;
      const b=document.createElement('div'); 
      b.className='tag'; 
      b.textContent=`${navSteps.length} instruções`;
      mi.append(a,b);

    }catch(e){
      console.error('Erro ao obter direções:', e);
      // Fallback: linha reta entre pontos
      plannedGeo={
        type:'LineString',
        coordinates:PONTOS.map(p=>[p.lon,p.lat])
      };
      
      updateRouteLayers([], plannedGeo.coordinates);
      
      const xs=PONTOS.map(p=>p.lon);
      const ys=PONTOS.map(p=>p.lat);
      MAP.fitBounds([
        [Math.min(...xs), Math.min(...ys)],
        [Math.max(...xs), Math.max(...ys)]
      ], {padding:60});
      
      setNext(`Rota ${rotaSel.id} — ${rotaSel.nome}`, 'Toque em "Iniciar Rota".');
      setStatus('Visão geral (rota direta)');
      navSteps=[];
      stepIdx=0;
    }
  }

  function startNavigation() {
    if (!plannedGeo?.coordinates?.length) { 
      alert('Mostre a visão geral antes de iniciar a navegação.'); 
      return; 
    }

    console.log('Iniciando navegação...');
    isNavigating = true;
    setStatus('Obtendo localização...');

    // Primeiro, tenta usar a posição atual
    navigator.geolocation.getCurrentPosition(
      position => {
        const lat = position.coords.latitude;
        const lon = position.coords.longitude;
        window.__lastGPS = { lat, lon };
        initializeNavigation(lat, lon);
      },
      error => {
        console.warn('Erro ao obter localização inicial:', error);
        // Fallback: usar primeiro ponto da rota
        const firstPoint = PONTOS[0];
        const lat = firstPoint.lat;
        const lon = firstPoint.lon;
        window.__lastGPS = { lat, lon };
        initializeNavigation(lat, lon);
        setStatus('Navegação simulada (use GPS real para melhor precisão)');
      },
      { 
        enableHighAccuracy: true, 
        timeout: 10000, 
        maximumAge: 0 
      }
    );
  }

  function initializeNavigation(lat, lon) {
    console.log('Inicializando navegação em:', lat, lon);
    
    // Criar/atualizar marcador do motorista
    if (!driverMarker) {
      const el = document.createElement('div');
      el.innerHTML = `<svg viewBox="0 0 24 24" width="44" height="44">
        <path d="M12 2 L20 20 L12 16 L4 20 Z" fill="#ff5e3a" stroke="#b03f2a" stroke-width="0.5"/></svg>`;
      driverMarker = new mapboxgl.Marker({ element: el, rotationAlignment: 'map' })
        .setLngLat([lon, lat])
        .addTo(MAP);
    } else {
      driverMarker.setLngLat([lon, lat]);
    }

    // Inicializar progresso na rota
    const initialProg = nearestProgress([lon, lat], plannedGeo.coordinates);
    startProg = { ...initialProg };
    lastProg = { ...initialProg };
    
    console.log('Progresso inicial:', startProg);

    // Renderizar rota inicial
    renderRouteProgress();
    
    // Centralizar no motorista
    MAP.flyTo({
      center: [lon, lat],
      zoom: 16,
      pitch: 60,
      bearing: 0,
      duration: 1000
    });

    // Configurar watch do GPS
    try {
      if (watchId) {
        navigator.geolocation.clearWatch(watchId);
      }
      
      watchId = navigator.geolocation.watchPosition(
        onGPSUpdate,
        onGPSError,
        {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 5000
        }
      );
      
      setStatus('Navegação ativa');
      if (navSteps[0]) {
        setNext(navSteps[0].text, 'Siga as instruções de navegação');
        speak(navSteps[0].text);
      }
      
      requestWakeLock();
      
    } catch (e) {
      console.error('Erro ao iniciar watchPosition:', e);
      setStatus('Erro ao iniciar GPS');
    }
  }

  function onGPSUpdate(position) {
    if (!isNavigating) return;
    
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    window.__lastGPS = { lat, lon };

    // Atualizar marcador do motorista
    if (driverMarker) {
      driverMarker.setLngLat([lon, lat]);
      
      // Atualizar rotação do marcador se houver heading
      if (position.coords.heading !== null) {
        const heading = smoothBearing(position.coords.heading);
        driverMarker.setRotation(heading);
      }
    }

    // Atualizar progresso na rota
    if (plannedGeo && plannedGeo.coordinates) {
      const currentProg = nearestProgress([lon, lat], plannedGeo.coordinates);
      
      // Atualizar apenas se houve progresso significativo
      if (!lastProg || (currentProg.index + currentProg.t) > (lastProg.index + lastProg.t + 0.001)) {
        lastProg = currentProg;
        renderRouteProgress();
      }

      // Atualizar câmera
      updateNavigationCamera(lon, lat, position.coords.heading);

      // Atualizar instruções
      updateNavigationInstructions(lat, lon);
    }
  }

  function onGPSError(error) {
    console.warn('Erro GPS:', error);
    let message = 'Erro GPS: ';
    switch(error.code) {
      case error.PERMISSION_DENIED:
        message += 'Permissão negada';
        break;
      case error.POSITION_UNAVAILABLE:
        message += 'Posição indisponível';
        break;
      case error.TIMEOUT:
        message += 'Timeout';
        // Continuar navegação com última posição conhecida se houver
        if (window.__lastGPS && isNavigating) {
          setStatus('GPS offline - usando última posição');
        }
        break;
      default:
        message += 'Erro desconhecido';
    }
    setStatus(message);
  }

  function renderRouteProgress() {
    if (!plannedGeo?.coordinates || !startProg || !lastProg) {
      console.log('Dados insuficientes para renderizar rota');
      return;
    }

    const coords = plannedGeo.coordinates;
    
    // Calcular trecho percorrido (cinza)
    const traveledCoords = sliceBetween(coords, startProg, lastProg);
    
    // Calcular trecho restante (azul)
    const remainingCoords = sliceFrom(coords, lastProg);
    
    console.log('Traveled:', traveledCoords.length, 'Remaining:', remainingCoords.length);
    
    // Atualizar camadas no mapa
    updateRouteLayers(traveledCoords, remainingCoords);
  }

  function updateRouteLayers(traveledCoords, activeCoords) {
    const features = [];
    
    if (traveledCoords && traveledCoords.length >= 2) {
      features.push({
        type: 'Feature',
        properties: { kind: 'traveled' },
        geometry: {
          type: 'LineString',
          coordinates: traveledCoords
        }
      });
    }
    
    if (activeCoords && activeCoords.length >= 2) {
      features.push({
        type: 'Feature',
        properties: { kind: 'active' },
        geometry: {
          type: 'LineString',
          coordinates: activeCoords
        }
      });
    }
    
    const featureCollection = {
      type: 'FeatureCollection',
      features: features
    };
    
    const source = MAP.getSource('route-source');
    if (source) {
      source.setData(featureCollection);
    }
  }

  function updateNavigationCamera(lon, lat, heading) {
    if (!MAP) return;
    
    const cameraOptions = {
      center: [lon, lat],
      zoom: 16.5,
      pitch: 65,
      duration: 1000
    };
    
    if (heading !== null && heading !== undefined) {
      cameraOptions.bearing = heading;
    }
    
    MAP.easeTo(cameraOptions);
  }

  function updateNavigationInstructions(lat, lon) {
    if (!navSteps.length || stepIdx >= navSteps.length) return;
    
    const currentStep = navSteps[stepIdx];
    const distance = Math.round(distanceM(lat, lon, currentStep.loc.lat, currentStep.loc.lon));
    
    setNext(currentStep.text, `${distance} m até a próxima manobra`);
    
    // Avançar para próxima instrução quando estiver próximo
    if (distance <= 50 && stepIdx < navSteps.length - 1) {
      stepIdx++;
      const nextStep = navSteps[stepIdx];
      if (nextStep) {
        speak(nextStep.text);
      }
    }
    
    // Verificar se chegou ao final
    const finalPoint = PONTOS[PONTOS.length - 1];
    const finalDistance = distanceM(lat, lon, finalPoint.lat, finalPoint.lon);
    if (finalDistance <= 50) {
      setNext('ROTA FINALIZADA', 'Você chegou ao destino final');
      speak('Rota finalizada. Você chegou ao destino.');
      stopNavigation();
    }
  }

  function pauseNavigation() {
    isNavigating = false;
    setStatus('Navegação pausada');
    if (watchId) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
  }

  function stopNavigation() {
    isNavigating = false;
    setStatus('Navegação finalizada');
    
    if (watchId) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
    
    releaseWakeLock();
    
    setNext('Navegação finalizada', 'Escolha outra rota ou recomece.');
  }

  function centerOnDriver() {
    if (driverMarker) {
      const pos = driverMarker.getLngLat();
      MAP.flyTo({
        center: [pos.lng, pos.lat],
        zoom: 16.5,
        pitch: 65,
        duration: 1000
      });
    }
  }

  /* ===== Wake Lock ===== */
  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock ativado');
      }
    } catch (e) {
      console.warn('Wake lock não suportado:', e);
    }
  }

  function releaseWakeLock() {
    try {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Wake lock liberado');
      }
    } catch (e) {
      console.warn('Erro ao liberar wake lock:', e);
    }
  }

  // Inicialização quando a página carrega
  document.addEventListener('DOMContentLoaded', function() {
    console.log('Sistema de rotas escolares inicializado');
    setStatus('Pronto para usar');
  });
  </script>
</body>
</html>
